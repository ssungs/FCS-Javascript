# 표현식(expression)과 문(statement)

## 값(value)

값이란 표현식을 해석해 생성된 값 또는 그 값을 참조하는 것

## 리터럴(literal)

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식

```
100 // 정수 리터럴
'Hello' // 문자열 리터럴
True, False // 불리언 리터럴
null // null 리터럴
undefined // undefined 리터럴
{'name':'kim'} // 객체 리터럴(python의 딕셔너리)
[1,2,3] // 배열 리터럴(python의 리스트)
function() {} // 함수 리터럴
/[A-Z]+/g // 정규표현식 리터럴
```

## 표현식(expression)

표현식은 값으로 평가될 수 있는 모든 문(statement)

리터럴은 값으로 평가 따라서 리터럴도 표현식

표현식과 평가된 값은 동치(equivalent)

```
var x = 1 + 2;
x + 3; // 표현식 x는 3으로 평가 따라서 3 + 3
>>6
```

## 문(statement)

문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위

문은 여러 토큰으로 구성

토큰은 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

```
var sum = 1 + 2; // 여기서 var, sum, =, 1, +, 2, ; 은 각자 모두 토큰이고 합쳐서 문
```

문은 명령문이라고도 부름

```
var x; // 변수 선언문
x = 5; // 할당문
function x () {} // 함수 선언문
for (var i = 0; i < 2; i++) { console.log(i); } // 반복문
```

## 표현식인 문과 표현식이 아닌 문

표현식은 문의 일부이거나 그 자체가 문이 됨

```
var x; // 변수 선언문은 값을 평가할 수 없으므로 표현식이 아님
x = 1 + 2; // 할달문에서 1 + 2 는 값으로 평가 가능하므로 표현식이자 완전한 문
```
표현식인지 구별하는 가장 간단 명료한 방법은 변수에 할당해 보는 것

# 데이터 타입(data type - 줄여서 타입(type))

타입은 값의 종류

타입은 7개의 데이터 타입을 제공하고 7개의 데이터 타입은 원시 타입과 객체 타입으로 분류

원시 타입 - 숫자, 문자열, 불리언, undefined, null, 심벌(symbol)

객체 타입 - 객체(딕셔너리), 함수, 배열(리스트)

## 템플릿 리터럴

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공

템플릿 리터널은 일반 문자열과 달리 '',"" 대신 ``을 사용

### 멀티라인 문자열

일반 문자열 내에서 줄바꿈이 허용되지 않음

줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용

```
\0	    Null
\b    	백스페이스
\f   	폼 피드 - 프린터로 출력할 경우 다음 페이지의 시작 지점으로 이동
\n  	다음 행으로 이동
\r  	커서를 처음으로 이동
\t  	탭(옆)
\v  	탭(아래)
\uXXXX	유니코드
\’	    작은따옴표
\”   	큰따옴표
\\  	백슬래시
```

### 표현식 삽입

문자열은 문자열 연산자 + 를 사용해 연결 가능

피연산자 중 하나 이상이 문자열인 경우 문자열로 인식해 문자열 연결 연산자로 동작

템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열 삽입 가능

가독성이 좋고 간편하게 문자열 조합 가능

```
var first = 'Java';
var last = 'script';
console.log(first + last + ' ' + 'is awesome.');
>>'Javascript is awesome.' // ES5 문자열 연결
console.log(`${first}${last} is awesome.`);
>>'Javascript is awesome.' // ES6 표현식 삽입
```

### 불리언 타입

불리언 타입의 값은 참, 거짓을 나타내는 true, false 두 가지

주로 조건문에서 사용

### undefined 타입

undefined 타입의 값은 undefined 가 유일

변수를 할당할 때 값을 주지 않으면 암묵적으로 undefined 값이 할당(undefined 로 초기화)

### null 타입

null 타입의 값은 null 이 유일

null 은 변수에 값이 없는 것을 의도적으로 명시할 때 사용

### 심볼(symbol) 타입

추후 예정

### 객체 타입

자바스크립트는 객체 기반의 언어, 자바스크립트를 이루고 있는 거의 모든 것이 객체

## 데이터 타입의 필요성

자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보

참조의 경우 값이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾는 것

저장되어 있는 값이 어떤 데이터 타입이냐에 따라 정해진 크기로 읽어 들이지 않으면 값이 훼손

데이터 타입의 필요성을 정리하면,

값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하고 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해서 필요

## 동적 타이핑과 정적 타이핑

정적 타입 언어란 변수를 선언할 때 변수에 할당할 수 있는 데이터 타입을 사전에 선언

변수의 타입을 변경할 수 없으며, 변수에 선언한 타입만 할당 가능

컴파일 시점에 타입 체크를 수행하고 타입의 일관성을 강제함으로써 코드가 안정적

동적 타입 언어란 변수를 선언할 때 변수에 데이터 타입을 선언하지 않고 할당

자바스크립트는 값을 알아서 판단해 런타임시 데이터 타입이 정해짐

따라서 변수의 타입을 쉽게 변경 가능하고, 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능

변수 값의 타입이 쉽게 변경 가능하기 때문에 변수 값의 타입을 확인하기 전까지 타입을 확신 할 수 없음

변수를 재할당하는 과정에서 혹시 타입의 변환이 일어났다고 한다면 확인하기 전까지는 개발자가 알 수 없기 때문에 재할당이 불가능한 const를 쓰거나 새로운 변수에 할당하는 것으로 위험을 방지

# 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만들때 사용

## 산술 연산자

```
// 이항 산술 연산자
1 + 2	덧셈
1 - 2	뺄셈
1 * 2	곱셈
1 / 2	나눗셈
1 % 2	나머지

// 단항 산술 연산자
i++	   증가  // 다른 연산 수행 후 피연산자의 값을 증가
++i    증가  // 피연산자의 값을 증가 후 다른 연산 수행
i--	   감소  // 다른 연산 수행 후 피연산자의 값을 감소
--i    감소  // 피연산자의 값을 감소 후 다른 연산 수행
+i	   어떠한 효과도 없다. 음수를 양수로 반전하지도 않음
-i	   양수를 음수로, 음수를 양수로 반전한 값을 반환

// 할당 연산자 - 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있음
x = 5	// x = 5 를 의미
x += 5	// x = x + 5 를 의미
x -= 5	// x = x - 5 를 의미
x *= 5	// x = x * 5 를 의미
x /= 5	// x = x / 5 를 의미
x %= 5	// x = x % 5 를 의미

// 비교 연산자 - 결과를 불리언 값으로 반환
==	  동등 비교	    x == y	  x와 y의 값이 같음 // 자주 안씀
===	  일치 비교  	x === y	  x와 y의 값과 타입이 같음 // 자주 쓰임
!=	  부동등 비교	x != y	  x와 y의 값이 다름
!==	  불일치 비교	x !== y   x와 y의 값과 타입이 다름

// 대소 관계 비교 연산자 - ( >, <, >=, <= )

// 삼항 조건 연산자 - 조건식의 평가 결과에 따라 반환할 값을 결정
// 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
// 두 가지 경우의 수
var x = 2;
var result = x % 2 ? '홀수' : '짝수'; // x % 2 는 0이고 false로 이해
console.log(result);
>>'짝수'
// 세 가지 경우의 수
var num = 2;
var kind = num ? (num > 0 ? '양수' : '음수') : '영';
console.log(kind);
>>'양수'

// if문과 삼항 조건 연산자의 차이
// if문은 표현식이 아닌 문이기 때문에 값처럼 사용 할 수 없음 즉, 변수 할당 불가
// 삼항 조건 연산자는 표현식인 문이기 때문에 값처럼 사용 가능 즉, 변수 할당 가능
// 수행해야 할 문이 여러개라면 if문이 가독성 측면에서는 더 좋음

// 논리 연산자
||	논리합(OR) - 둘중 하나라도 true면 true
&&	논리곱(AND) - 둘다 true면 true 하나만 true면 false
!	부정(NOT) - 반대. true면 false

// 쉼표(,) 연산자
var x, y, z;
x = 1, y = 2, z = 3; // 차례대로 평가하고 마지막 피연산자의 평가 결과를 반환
>>3

// 그룹(()) 연산자
10 * 2 + 3;
>>23
10 * (2 + 3); // 그룹 연산자로 우선순위를 조절 가능
>>50

// typeof 연산자
// 7가지 타입 중 맞는 하나의 타입을 반환하지만 정확히 일치하지는 않음

// 지수 연산자 - 제곱으로 이항 연산자 중에서 우선순위가 가장 높음
2 ** 2;
>>4
```

# 제어문

## 블록문

블록문은 0개 이상의 문을 중괄호({})로 묶은 것으로 코드 블록 또는 블록이라고 부름

블록문은 자체 종결성을 갖기 때문에 세미콜론을 붙이지 않음

## 조건문

조건문은 조건식의 평가 결과에 따라 코드 블록의 실행을 결정

### if문

if문은 조건식이 참이냐 거짓이냐에 따라 실행할 코드 블록을 결정

```
// 기본구조 - 코드 블록 내의 문이 하나뿐이라면 중괄호 생략 가능
if (조건식) {코드블록;} else if (조건식) {코드블록;} else {코드블록;}

var num = 2;
var kind;
if (num > 0) {   // 양수인지 판단
  kind = '양수';
} else if (num < 0) {   // 음수인지 판단
  kind = '음수';
} else {    // 그 외에 모든 경우
  kind = '영';
}
console.log(kind);
>>'양수'
```

### switch문

switch문은 주어진 표현식을 평가해 일치하는 표현식을 갖는 case문을 실행

만약 일치하는 표현식이 없다면 default문으로 이동

default문은 선택사항으로 사용하지 않아도 됨

break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 흐름이 다음 case 문으로 연이어 이동

```
// 기본구조
switch (표현식) {case 표현식1: 실행될 문; break; default: default에서 실행될 문}

var month = 11;
var monthName;

switch (month) {
  case 1: monthName = 'January';
    break;
  case 2: monthName = 'February';
    break;
  case 3: monthName = 'March';
    break;
  case 4: monthName = 'April';
    break;
  case 5: monthName = 'May';
    break;
  case 6: monthName = 'June';
    break;
  case 7: monthName = 'July';
    break;
  case 8: monthName = 'August';
    break;
  case 9: monthName = 'September';
    break;
  case 10: monthName = 'October';
    break;
  case 11: monthName = 'November';
    break;
  case 12: monthName = 'December';
    break;
  default: monthName = 'Invalid month';
}
console.log(monthName);
>>'November'
```

## 반복문

반복문은 조건식의 평가 결과가 거짓 일 때까지 코드 블록을 반복해서 실행

### for문

for문은 조건식이 거짓으로 평가될 때까지 코드 블록은 반복 실행

반복 횟수가 명확할 때 주로 사용

for문 안에서 반복수행 할 변수를 지정

```
// 기본구조
for (변수선언문 또는 할당문; 조건식; 증감식;) {코드 블록;}
for (var i = 0; i < 2; i++) {
  console.log(i);
} // 변수선언 = 0 i가 2보다 작으므로 코드블록 실행 i++ 반복 i가 2보다 크거나 작을때 까지
>>0
>>1
```

### while문

while문은 조건식이 참이면 코드 블록을 계속해서 반복 실행

반복 횟수가 불명확할 때 주로 사용

while문 바깥에 반복수행 할 변수를 지정해줘야 함

```
// 기본구조
while (조건식) {코드블록;}
var count = 1;
while (count < 3) {
  console.log(count);
  count++;
}
>>1
>>2
// do while문
do while문은 코드블록을 먼저 실행하고 조건식으로 평가
// 기본구조
do {코드블록;} while (조건식);
var count = 0;
do {
  console.log(count);
  count++;
} while (count < 3);
>>0
>>1
>>2
```

### break문

break문은 코드 블록을 탈출 정확히는 레이블문, 반복문의 코드 블록을 탈출

```
var string = 'Hello World.';
var search = 'l';
var index;
for (var i = 0; i < string.length; i++) {
  if (string[i] === search) {
    index = i;
    break;
  }
}
console.log(index);
>>2 // search의 'l'과 같은 문자열을 가지는 string의 인덱스는 2
```

### continue문

continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식을 실행

```
var string = 'Hello World.';
var search = 'l';
var count = 0;
for (var i = 0; i < string.length; i++) {
  if (string[i] !== search) continue;
  count++; // continue 문이 실행되면 이 문은 실행 안됨
}
console.log(count);
>>3 // string의 문자열에서 search의 'l'과 같은 문자열의 갯수는 3
```
