# 함수

자바스크립트에서 가장 중요한 핵심 개념

함수를 정의 할 때 파라미터(매개변수, 인자)는 변수가 선언 되어지기 때문에 네이밍에 신경써야함 

이 변수는 함수내에서만 동작하는 스코프(범위)를 가짐

파라미터는 0개 이상이 올 수 있고 순서에 의미가 있음

## 함수 리터럴

자바스크립트의 함수는 객체 타입의 값. 따라서 함수도 함수리터럴로 생성

함수 리터럴은 function 키워드, 함수 이름, 매개변수, 함수 코드 블록 으로 구성

이름 없이 몸체만 있는 함수를 함수 리터럴

## 함수 선언

함수를 정의 하는 방법은 크게 3가지로 나뉨

함수 선언문 - 런타임 이전에 실행 > 함수 호이스팅이 일어남

따라서 선언 전에 함수 호출이 가능

함수 표현식 - 런타임에 실행 > 변수 호이스팅이 일어남

따라서 선언 전에 함수 호출이 불가능

함수 표현식에서 함수 이름은 함수 내에서만 유효하고 주로 디버깅, 재귀에 이용 됨

함수 이름은 생략 가능하고 일반적으로 생략해서 사용

화살표 함수 - 추후 예정

함수 선언문과 함수 표현식 중 아무거나 자유롭게 사용하되 일관성 있게 사용

하지만 주로 화살표 함수를 사용

```
//기본구조
function 변수명(동사-명령형) (파라미터 - 0개 이상) { 코드 블록; } // 함수 정의 (함수 선언문)
변수명(알규먼츠 - 인수); // 함수 호출 (함수 호출문 - 표현식)

// 함수 선언문
function add (x, y) {
  return x + y;
}

// 함수 표현식 - 런타임에 실행 > 변수 호이스팅이 일어남
var add = function (x, y) {  
    return x + y;
}

// 화살표 함수
const add = () => a + b;

```

## 함수 호출

함수도 제어문의 일종 - 서브 루틴

함수 호출문 - 함수는 항상 호출해야 의미가 있음

함수 호출을 할 때 넣어주는 값인 알규먼트(인수)는 항상 함수 밖에 존재하고

매개변수에 인수가 할당되어 지는 것

## 매개변수의 최대 개수

매개변수의 개수는 0개가 가장 이상적

3개 이상은 객체로 묶어서 전달

arguments(유사 배열 객체)로 전달 가능 > 유사 배열 객체는 자체적으로 length 속성을 가지고 있음

다만 객체를 사용할 때는 값이 함수 내에서 변경될 가능성을 염두에 두고 변하지 않도록 주의

```
// arguments 사용
function sum () {
  var result = 0 
  for (var i = 0; i < arguments.length; i++) {  
    result += arguments[i]
  }
  return result;
}
console.log(sum(1, 2, 3, 4));
>>10

// reduce 사용
function sum ( ...args) {
  return args.reduce((p, c) => p + c, 0);
}
console.log(sum(1, 2, 3, 4));
>>10
```

## 다양한 함수의 형태

### 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수

즉시 실행 함수는 단 한 번만 호출되며 다시 호출 불가능

```
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}()); // 예전 방식 지금은 ()를 밖에 써주는 것이 일반적 >> (function(){})()

// 기명 즉시 실행 함수
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
}());
foo(); // 함수가 즉시 실행 되고 나면 참조할 수 없는 식별자로 다시 호출 불가
>>Error: foo is not defined
```

### 재귀 함수

함수 내에서 자기 자신을 호출하는 함수(무한 반복)

비슷한 일을 여러번 반복할 때 재귀함수를 사용

### 중첩 함수

함수 내부에서 함수를 선언

중첩은 대부분 부자 관계를 만들고 상속이 일어남을 의미

### 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수

고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출

콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달 따라서 고차 함수에 콜백 함수를 전달할 때 함수 자체를 전달

자바스크립트는 대부분 콜백 함수

```
// 콜백 함수를 사용하는 고차 함수 map
var res = [1, 2, 3].map(function (item) {
  return item * 2;
});
console.log(res);
>>[2, 4, 6]

// 콜백 함수를 사용하는 고차 함수 filter
res = [1, 2, 3].filter(function (item) {
  return item % 2;
});
console.log(res);
>>[1, 3]

// 콜백 함수를 사용하는 고차 함수 reduce
res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur;
}, 0);
console.log(res);
>>6
```

### 순수 함수와 비순수 함수

순수 함수는 동일한 인수가 전달되면 동일한 값을 반환하는 함수

비순수 함수는 동일한 인수가 전달되어도 return값이 다를 수 있음

# 스코프

소스코드는 4가지로 나뉨

전역코드 - 글로벌, 함수외부에 존재하고 실행 시 스코프 객체가 만들어짐

함수코드 - 함수 내부에 존재하고 실행 시 함수 스코프가 만들어짐(호출시 지역 변수 스코프에 추가)

Eval코드, 모듈코드 는 추후예정

```
var x = 1; // 전역 변수 - 함수 내부를 제외하고 전부 전역

function foo() {
  var y = 2; 
  console.log(x);
}
foo(); // 지역 변수 - 함수 내부
>>1

function foo() {
  var y = 2; 
  console.log(x);

  fumction bar() {  
    console.log(y);
  }
  bar();
}
```

## 함수 레벨 스코프

var키워드로 선언된 변수는 함수의 코드블록만을 스코프로 인정 - 중복 선언 허용

함수내에 선언된 것이 아니라면 전역으로 인식

```
var i = 10;
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
console.log(i);
>>5
```

## 렉시컬 스코프

함수가 정의된 위치를 기준으로 봄

```
var x = 1;
function foo() {
  var x = 10;
  bar();
}
function bar() {
  console.log(x);
}
foo();
>>1
bar();
>>1
```

# 전역 변수의 문제점

암묵적 결합 - 어디서든 재할당이 가능(변수 값이 바뀔 가능성이 높고 추적하기 어려움)

긴 생명 주기 - 브라우저가 켜지고 꺼질때까지 생명을 가짐(메모리 공간 사용)

스코프 체인 상에서 종점에 존재 - 퍼포먼스 측면에서 손해

네임스페이스 오염 - 쓸 수 있는 변수명이 점점 줄어듬

따라서 최대한 사용하지 않는 방법을 강구

## 전역 변수의 사용을 억제하는 방법

즉시 실행함수로 모든 코드를 감쌈(오래된 방식)

모듈 사용 - ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공

# let, const와 블록 레벨 스코프

var키워드의 문제점들 - 중복 선언 허용, 변수 호이스팅, 함수 레벨 스코프

중복 선언을 허용하지 않음

변수 호이스팅이 발생하지만 발생하지 않는 것 처럼 동작

블록 레벨 스코프

일단 const를 쓰고 재할당이 필요하다면 let으로 변경

왠만하면 재할당을 하지 않는 쪽으로 코드를 짬

## let

재할당이 가능

## const

재할당이 불가능

선언과 동시에 초기화(할당)를 해주어야 함
